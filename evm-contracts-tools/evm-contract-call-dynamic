#!/usr/bin/env node

// SPDX-License-Identifier: AGPL-3.0-or-later

/**    ----------------------------------------------------------------------
 *     Copyright Â©
 *       Pellegrino Prevete
 *         2024, 2025, 2026
 * 
 *     All rights reserved
 *     ----------------------------------------------------------------------
 * 
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 * 
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 * 
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

const
  _libcrash =
    require(
      '../libcrash-js/crash-js');
_cmdline_check =
  _libcrash._cmdline_check;
_dirname =
  _libcrash._dirname;
_error_display =
  _libcrash._error_display;
_msg_info =
  _libcrash._msg_info;
_msg_error =
  _libcrash._msg_error;
_path_join =
  _libcrash._path_join;
_sleep =
  _libcrash._sleep;
const
  { ethers } =
    require(
      "ethers");
_ethers =
  ethers;
_wei_to_ether =
  _ethers.formatEther;
_parse_units =
  _ethers.parseUnits;
const
  _price_gas_transaction_get_module =
    require(
      '../evm-wallet/price-gas-transaction-get');
_price_gas_transaction_get =
  _price_gas_transaction_get_module._price_gas_transaction_get;
const
  _contract_get_module =
    require(
      './contract-get');
_contract_get =
  _contract_get_module._contract_get;

function
  _global_variables() {
  app_name =
    "evm-contract-call-dynamic";
  retries_max =
    "";
  call_timeout =
    "";
  wallet_seed =
    "";
  wallet_password =
    "";
  api_key_path =
    "";
  price_gas =
    "";
  msg_value =
    "";
  measure_unit =
    "";
  target_network =
    "";
  contract_address =
    "";
  contract_abi_path =
    "";
  contract_bytecode_path =
    "";
  contract_compiler_output_path =
    "";
  contract_method =
    "";
  method_args =
    [];
  quiet =
    "";
}

function
  _msg_info_wallet_selected(
    _wallet_path) {
  let
    _msg,
    _template;
  _template =
    "Selecting '{_wallet_path}'.";
  _msg =
    _template.replaceAll(
      "{_wallet_path}",
      _wallet_path);
  _msg_info(
    _msg);
}

async function
  _msg_info_contract_obtained(
    _contract) {
  let
    _msg,
    _template;
  _template =
    "Contract object '{_contract}' obtained.";
  _msg =
    _template.replaceAll(
      "{_contract}",
      _contract);
  _msg_info(
    _msg);
}

function
  _msg_info_method_obtained(
    _method) {
  let
    _msg;
  _msg =
    "Method obtained.";
  _msg_info(
    _msg);
}

function
  _msg_error_transaction_undefined(
    _attempt) {
  let
    _msg,
    _template;
  _template =
    "Transaction undefined at attempt '{_attempt}'.";
  _msg =
    _template.replaceAll(
      "{_attempt}",
      _attempt);
  _msg_info(
    _msg);
  _msg_error(
    _msg,
    0);
}

function
  _msg_error_transaction_failed(
    _attempt) {
  let
    _msg;
  _msg =
    `Transaction failed at attempt '${_attempt}'.`;
  _msg_error(
    _msg,
    0);
}

function
  _ethers_to_wei(
    _amount) {
  return _parse_units(
    _amount,
    "ether");
}

async function
  _contract_call_dynamic(
    _call_timeout,
    _wallet_seed,
    _wallet_password,
    _api_key_path,
    _price_gas,
    _msg_value,
    _measure_unit,
    _target_network,
    _contract_address,
    _contract_abi_path,
    _contract_bytecode_path,
    _contract_compiler_output_path,
    _contract_method,
    _method_args) {
  let
    _amount,
    _contract,
    _contract_get_opts,
    _fee_priority,
    _gas_fee,
    _method,
    _msg,
    _eip_1559,
    _price_feasible_retries,
    _price_feasible_retries_max,
    _price_gas_max,
    _price_gas_transaction_get_args,
    _price_gas_transaction_get_retries_max,
    _price_gas_transaction_get_selection_mode,
    _retries_max,
    _send_opts,
    _receipt,
    _tx;
  _eip_1559 =
    true;
  _price_gas_max =
    400000;
  _send_opts =
    {};
  if ( typeof(
         _measure_unit) === "undefined" ||
         _measure_unit == "" ) {
    _measure_unit =
      "wei";
  }
  if ( typeof(
         _price_gas) === "undefined" ||
         _price_gas == "" ) {
    _price_gas =
      0;
  }
  if ( _price_gas == "auto" ||
       _price_gas == "fast" ) {
    _msg =
      `Auto-detecting gas price.`;
    _msg_info(
      _msg);
    _price_gas_transaction_get_selection_mode =
      "fast";
    _retries_max =
      3;
    _price_feasible_retries_max =
      _retries_max;
    _price_gas_transaction_get_retries_max =
      _retries_max;
    _price_gas_transaction_get_args = [
      _target_network,
      _price_gas_transaction_get_selection_mode,
      _api_key_path,
      _measure_unit,
      "",      // wallet seed
      "",      // target address,
      "price", // output type
      "",      // output file
      _price_gas_transaction_get_retries_max
    ];
    _price_gas = await
      _price_gas_transaction_get.apply(
        null,
        _price_gas_transaction_get_args);
    _price_gas_transaction_get_args = [
      _target_network,
      _price_gas_transaction_get_selection_mode,
      _api_key_path,
      _measure_unit,
      "",    // wallet seed
      "",    // target address,
      "fee", // output type
      "",    // output file
      _price_gas_transaction_get_retries_max
    ];
    _gas_fee = await
      _price_gas_transaction_get.apply(
        null,
        _price_gas_transaction_get_args);
    _price_gas_transaction_get_args = [
      _target_network,
      _price_gas_transaction_get_selection_mode,
      _api_key_path,
      _measure_unit,
      "",         // wallet seed
      "",         // target address,
      "priority", // output type
      "",         // output file
      _price_gas_transaction_get_retries_max
    ];
    _fee_priority = await
      _price_gas_transaction_get.apply(
        null,
        _price_gas_transaction_get_args);
    _msg =
      `Got gas price '${_price_gas}' ` +
      `${_measure_unit} with '${_gas_fee}' ` +
      `'${_measure_unit}' with priority fee ` +
      `'${_fee_priority}' '${_measure_unit}' from rpc ` +
      `'${_target_network}' using ` +
      `selection mode ` +
      `'${_price_gas_transaction_get_selection_mode}'.`;
    _msg_info(
      _msg);
  }
  _price_gas =
    Number(
      _price_gas);
  if ( typeof(
         _msg_value) === "undefined" ) {
    _msg_value =
      0;
  }
  _msg_value =
    Number(
      _msg_value);
  if ( typeof(
         _call_timeout) === "undefined" ||
       _call_timeout == "" ) {
    _msg_info(
      "Setting timeout to '300' seconds.");
    _call_timeout =
      300000;
  }
  else {
    _call_timeout =
      Number(
        _call_timeout);
  }
  _contract_get_opts = [
    _wallet_seed,
    _wallet_password,
    _contract_address,
    _contract_abi_path,
    _contract_bytecode_path,
    _contract_compiler_output_path,
    _target_network,
    _api_key_path,
  ];
  try {
    _contract =
      await _contract_get.apply(
        null,
        _contract_get_opts);
    await _msg_info_contract_obtained(
      _contract);
    _method =
      await _contract.getFunction(
        _contract_method);
    _msg_info_method_obtained(
      _method);
    if ( _price_gas > 0 ) {
      try {
        _tx = await
          _method.populateTransaction.apply(
          null,
          _method_args);
      }
      catch(
        _error) {
        _msg =
          "Error populating transaction.";
        _error_display(
          _error);
        _msg_error(
          _msg,
          0);
      }
      if ( quiet == "n" ) {
        _msg =
          "Generated transaction.";
        _msg_info(
          _msg);
        console.log(
          _tx);
      }
      _gas_limit =
        _price_gas * 2;
      _msg =
        `Setting gas price '${_price_gas}' ` +
        `${_measure_unit}, gas limit '${_gas_limit}' ` +
        `'${_measure_unit}' gas fee '${_gas_fee}' ` +
        `${_measure_unit}' and fee priority ` +
        `'${_fee_priority}' '${_measure_unit}'.`;
      _msg_info(
        _msg);
      if ( _eip_1559 == false ) {
        _tx[
          "gasPrice"] =
          _price_gas;
      }
      else if ( _eip_1559 == true ) {
        _price_feasible_retries =
          0;
        while( _price_gas_max < Number(_price_gas) &&
               _price_feasible_retries <= _price_feasible_retries_max ) {
          _price_feasible_retries =
            _price_feasible_retries + 1;
          _msg =
            `Current gas price '${_price_gas}', ` +
	    `maximum gas price '${_price_gas_max}'. ` +
            `Waiting 30 seconds before retrying.`;
          _msg_info(
            _msg);
          await _sleep(
            30000);
          _price_gas_transaction_get_args = [
            _target_network,
            _price_gas_transaction_get_selection_mode,
            _api_key_path,
            _measure_unit,
            "",      // wallet seed
            "",      // target address,
            "price", // output type
            "",      // output file
            _price_gas_transaction_get_retries_max
          ];
          _price_gas = await
            _price_gas_transaction_get.apply(
              null,
              _price_gas_transaction_get_args);
          _gas_limit =
            _price_gas;
          if ( Number(_price_gas) <= _price_gas_max ) {
            _gas_fee = await
              _price_gas_transaction_get.apply(
                null,
                _price_gas_transaction_get_args);
            _price_gas_transaction_get_args = [
              _target_network,
              _price_gas_transaction_get_selection_mode,
              _api_key_path,
              _measure_unit,
              "",         // wallet seed
              "",         // target address,
              "priority", // output type
              "",         // output file
              _price_gas_transaction_get_retries_max
            ];
            _fee_priority = await
              _price_gas_transaction_get.apply(
                null,
                _price_gas_transaction_get_args);
	  }
        }
        if ( _price_feasible_retries_max < _price_feasible_retries ) {
          _msg =
            `Setting price to max price ` +
            `'${_price_gas_max}'`;
          _msg_info(
            _msg);
          _price_gas =
            _price_gas_max;
        }
        _price_feasible_retries =
          _price_feasible_retries + 1;
        _price_gas_max =
          Math.max(
            _price_gas_max,
            _gas_limit,
            _gas_fee,
            _fee_priority,
            _price_gas,
        );
        _tx[
          "gasLimit"] =
          _gas_limit;
        _tx[
          "maxFeePerGas"] =
          _gas_fee;
        _tx[
          "maxPriorityFeePerGas"] =
          _fee_priority;
      }
      if ( quiet == "n" ) {
        console.log(
          _tx);
      }
      if ( _msg_value > 0 ) {
        if ( _measure_unit == "ether" ) {
          _amount =
            _ethers_to_wei(
              _msg_value);
        }
        else if ( _measure_unit == "wei" ) {
          _amount =
            _msg_value;
        }
        else if ( _measure_unit == "" ) {
          _amount =
            _msg_value;
        }
        else {
          _msg =
            `Unknown measure unit '${_measure_unit}'.`;
          _msg_error(
            _msg,
            1);
        }
        _tx[
          "value"] =
            _amount;
        // _method_args.push(
        //   _send_opts);
      }
      _tx = await
        _contract.runner.sendTransaction(
        _tx);
      // _tx =
      //   await _method.send.apply(
      //     null,
      //     _method_args)
    }
    else {
      _msg =
        "Setting no gas price.";
      _msg_info(
        _msg);
      if ( _msg_value > 0 ) {
        if ( _measure_unit == "ether" ) {
          _amount =
            _ethers_to_wei(
              _msg_value);
        }
        else if ( _measure_unit == "wei" ) {
          _amount =
            _msg_value;
        }
        else if ( _measure_unit == "" ) {
          _amount =
            _msg_value;
        }
        else {
          _msg =
            `Unknown measure unit '${_measure_unit}'.`;
          _msg_error(
            _msg,
            1);
        }
        _send_opts[
          "value"] =
            _amount;
        _method_args.push(
          _send_opts);
      }
      _tx =
        await _method.send.apply(
          null,
          _method_args)
    }
    if ( _tx == undefined ) {
      _msg = {
        "code":
	  444444, 
        "message":
          "Transaction response undefined." };
      throw _msg;
    }
    if ( quiet == "n" ) {
      console.log(
        _tx);
    }
    _receipt =
      await _tx.wait(
        1,
        _call_timeout);
  } catch (
      _error) {
    if ( "code" in _error ) {
      if ( _error["code"] == -32010 ) {
      _msg_info(
        _error[
          "message"]);
      }
      else {
        _msg =
          "Unknown error."
        _msg_error(
          _msg,
          0);
      _error_display(
        _error)
      }
    }
    _msg_info(
      _error[
        "code"]);
    _msg =
      "Dynamic contract call crashed.";
    _msg_info(
      _msg);
    throw _error;
  };
  return _receipt;
}

async function
  _contract_run(
    _retries_max,
    _call_timeout,
    _wallet_seed,
    _wallet_password,
    _api_key_path,
    _price_gas,
    _msg_value,
    _measure_unit,
    _target_network,
    _contract_address,
    _contract_abi_path,
    _contract_bytecode_path,
    _contract_compiler_output_path,
    _contract_method,
    _method_args,
    _output_file) {
  let
    _msg,
    _tx,
    _contract_call_dynamic_opts,
    _wallet_path_list,
    _wallet_path;
  if ( typeof(
         _price_gas) === "undefined" ||
       _price_gas == "" ) {
    _msg =
      "Setting no gas price.";
    _msg_info(
      _msg);
    _price_gas =
      "";
  }
  if ( typeof(
         _retries_max) === "undefined" ||
       _retries_max == "" ) {
    _msg =
      "Setting maximum call retries to '100'.";
    _msg_info(
      _msg);
    _retries_max =
      100;
  }
  _retries_max =
    Number(
      _retries_max);
  if ( typeof(
         _call_timeout) === "undefined" ||
       _call_timeout == "" ) {
    _msg =
      "Setting timeout to '300' seconds.";
    _msg_info(
      _msg);
    _call_timeout =
      300000;
  }
  _call_timeout =
    Number(
      _call_timeout);
  if ( typeof(
         _msg_value) === "undefined" ||
       _msg_value == "" ) {
    _msg =
      "Setting transaction value '0'.";
    _msg_info(
      _msg);
    _msg_value =
      0;
  }
  _msg_value =
    Number(
      _msg_value);
  if ( typeof(
         _measure_unit) === undefined ||
       _measure_unit == "" ) {
    _msg =
      "Setting measure unit to 'wei'.";
    _msg_info(
      _msg);
    _measure_unit =
      "wei";
  }
  if ( typeof(
         _wallet_password) === "undefined" ||
       _wallet_password == "" ) {
    _msg =
      "Wallet without password.";
    _msg_info(
      _msg);
  }
  _wallet_path =
    "";
  if ( typeof(
         _wallet_path) === "undefined" ||
       _wallet_path == "" ) {
    _wallet_path_list = [
      _dirname(
        _wallet_seed),
      "wallet.dat"];
    _wallet_path =
      _path_join(
        _wallet_path_list);
      _msg_info_wallet_selected(
        _wallet_path);
  }
  _contract_call_dynamic_opts = [
    _call_timeout,
    _wallet_seed,
    _wallet_password,
    _api_key_path,
    _price_gas,
    _msg_value,
    _measure_unit,
    _target_network,
    _contract_address,
    _contract_abi_path,
    _contract_bytecode_path,
    _contract_compiler_output_path,
    _contract_method,
    _method_args
  ];
  _attempt =
    1;
  while ( _attempt <= _retries_max ) {
    try {
      _tx =
        await _contract_call_dynamic.apply(
          null,
          _contract_call_dynamic_opts);
      if ( _tx == undefined ) {
        _msg_error_transaction_undefined(
          _attempt);
        throw "Transaction undefined."
      }
      else if ( _tx != undefined ) {
        if ( quiet == "n" ) {
          console.log(
            _tx);
	}
        if ( _tx.hash != undefined ) {
          _msg =
            "Transaction sent.";
          _msg_info(
            _msg);
          break;
        }
        else if ( _tx.hash == undefined ) {
        _msg_error_transaction_failed(
          _attempt);
        throw "Transaction hash undefined."
        }
        else {
        _msg_error_transaction_failed(
          _attempt);
        throw "Unknown transaction error."
        }
      }
    } catch (
        _error) {
      _error_display(
        _error);
      _msg =
        "Waiting 3 seconds before retrying.";
      _msg_info(
        _msg);
      await _sleep(
        3000);
        _attempt =
          _attempt + 1;
    }
  }
  if ( _attempt > _retries_max ) {
    throw "Maximum number of retries reached.";
  }
  return _tx;
}

function
  _overrides_set() {
  if ( retries_max == "" ) {
    retries_max =
      100;
  }
  if ( call_timeout == "" ) {
    call_timeout =
      300000;
  }
  if ( msg_value == "" ) {
    msg_value =
      0;
  }
  if ( measure_unit == "" ) {
    measure_unit =
      "wei";
  }
}

function
  _usage(
    _exit_code) {
  let
    _text;
  _text = [
    "Execute a dynamic call to an EVM network's contract method.",
    "",
    "Usage:",
    "  evm-contract-call-dynamic",
    "    <quiet>",
    "    <retries-max>",
    "    <call-timeout>",
    "    <wallet-seed>",
    "    <wallet-password>",
    "    <api-key-path>",
    "    <price-gas>",
    "    <msg-value>",
    "    <measure-unit>",
    "    <target-network>",
    "    <contract-address>",
    "    <contract-abi_path>",
    "    <contract-bytecode_path>",
    "    <contract-compiler-output_path>",
    "    <contract-method>",
    "    [method-args]",
    "",
    "Args:",
    "  <quiet>                          Can be 'y' or 'n'",
    "                                   Default: y",
    "  <retries-max>                    Maximum number of retries before",
    "                                   failing.",
    "  <call-timeout>                   How many milliseconds to wait for a return",
    "                                   before declaring the call failed.",
    "  <wallet-seed>                    Path of the file containing",
    "                                   the seed phrase.",
    "  <wallet-password>                Password of the wallet.",
    "  <api-key-path>                   Path of the API key for the",
    "                                   contract ABI provider service.",
    "  <target-network>                 Network on which the contract",
    "                                   resides.",
    "  <price-gas>                      Gas price for the transaction.",
    "  <msg-value>                      How much <measure-unit> attach",
    "                                   to the transaction.",
    "                                   Default: 0",
    "  <measure-unit>                   Measure unit for the transaction",
    "                                   value. It can be 'wei' or 'ether'",
    `                                   Default: ${measure_unit}`,
    "  <contract-address>               Address of the contract.",
    "  <contract-abi_path>              Contract ABI path.",
    "  <contract-bytecode-path>         Path for the contract bytecode.",
    "  <contract-compiler-output-path>  Path for the contract compiler",
    "                                   output path (the hardhat artifact).",
    "  <contract-method>                Contract method to execute.",
    "  [method-args]                    Arguments to pass to the method.",
    "",
    "  Options:",
    "    -h (--help)                    This help."
  ]
  for ( let
          _line =
            0;
        _line < _text.length;
        _line++ ) {
    _msg_info(
      _msgs[
        _line]);
  }
  process.exit(
    _exit_code);
}

function
  _config_show() {
  let
    _chars_max,
    _line,
    _method_args,
    _text;
  _chars_max =
    300;
  _method_args =
    method_args.join(
    " ");
  if ( _chars_max < _method_args.length ) {
    _method_args =
      _method_args.substring(
        0,
        _chars_max);
  }
  _text = [
    "Dynamic call configuration:",
    `            Measure unit: ${measure_unit}`,
    `             Max retries: ${retries_max}`,
    `      Network settings:`,
    `          Target network: ${target_network}`,
    `            API Key path: ${api_key_path}`,
    `            Call timeout: ${call_timeout}`,
    `               Gas price: ${price_gas}`,
    `  Credentials settings:`,
    `             Wallet seed: ${wallet_seed}`,
    `         Wallet password: ${wallet_password}`,
    `     Contract settings:`,
    `        Contract address: ${contract_address}`,
    `            Contract ABI: ${contract_abi_path}`,
    `       Contract Bytecode: ${contract_bytecode_path}`,
    `Contract compiler output: ${contract_compiler_output_path}`,
    `         Call settings:`,
    `       Transaction value: ${msg_value}`,
    `         Contract method: ${contract_method}`,
    `             Method args: ${_method_args}`,
  ];
  for (_line of _text)  { 
    _msg_info(
      _line);
  }
}

function
  _cmdline_parse() {
  let
    _msg;
  quiet =
    "y";
  process.argv.forEach(
    function (
      _value,
      _index,
      _array) {
      if ( _index == 2 ) {
        quiet =
          _value;
      }
      if ( _index == 3 ) {
        retries_max =
          _value;
      }
      if ( _index == 4 ) {
        call_timeout =
          _value;
      }
      if ( _index == 5 ) {
        wallet_seed =
          _value;
      }
      if ( _index == 6 ) {
        wallet_password =
          _value;
      }
      if ( _index == 7 ) {
        api_key_path =
          _value;
      }
      if ( _index == 8 ) {
        price_gas =
          _value;
      }
      if ( _index == 9 ) {
        msg_value =
          _value;
      }
      if ( _index == 10 ) {
        measure_unit =
          _value;
      }
      if ( _index == 11 ) {
        target_network =
          _value;
      }
      if ( _index == 12 ) {
        contract_address =
          _value;
      }
      if ( _index == 13 ) {
        contract_abi_path =
          _value;
      }
      if ( _index == 14 ) {
        contract_bytecode_path =
          _value;
      }
      if ( _index == 15 ) {
        contract_compiler_output_path =
          _value;
      }
      if ( _index == 16 ) {
        contract_method =
          _value;
      }
      if ( 16 < _index ) {
        method_args.push(
          _value);
      }
      if ( _value == "-h" ||
           _value == "--help" ) {
        quiet =
          "n";
        _usage(
          0);
      }
  });
  if ( contract_address == "" ) {
    _msg =
      "No contract address specified.";
    _msg_error(
      _msg,
      0);
    quiet =
      "n";
    _usage(
      1);
  }
}

if ( _cmdline_check(
       "evm-contract-call-dynamic") ) {
  _global_variables();
  _cmdline_parse();
  _config_show();
  _overrides_set();
  app_opts = [
    retries_max,
    call_timeout,
    wallet_seed,
    wallet_password,
    api_key_path,
    price_gas,
    msg_value,
    measure_unit,
    target_network,
    contract_address,
    contract_abi_path,
    contract_bytecode_path,
    contract_compiler_output_path,
    contract_method,
    method_args
  ];
  _contract_run.apply(
    null,
    app_opts);
}

module.exports = {
  _contract_call_dynamic:
    _contract_call_dynamic,
  _contract_run:
    _contract_run
};
