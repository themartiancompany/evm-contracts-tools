#!/usr/bin/env node

const { ethers } = require("ethers");
_ethers = ethers;
_fs = require("fs");

function _global_variables() {
  app_opts = [];
  wallet_path = "";
  wallet_password = "";
  wallet_seed = "";
  target_network = "";
  api_key = "";
}

function _file_exists(
  _path) {
  _return = false
  if (_fs.existsSync(
        _path)) {
  _return = true;
  }
  return _return;
}

function _wallet_exists(
  _path) {
  if ( _file_exists(
         _path) == true ) {
    _msg = "ERROR: wallet '{_path}' already exists".replaceAll(
      '{_path}',
      _path);
    console.error(
      _msg);
    process.exit();
  }
}

function _file_read(
  _path) {
  return _fs.readFileSync(
    _path,
    {"encoding": "utf8",
     "flag": 'r'});
}

function _wallet_get(
  _path,
  _password,
  _seed,
  _provider) {
  console.log(
    "INFO: generating new wallet", _path);
  console.log(
    "INFO: password", _password);
  console.log(
    "INFO: phrase", _seed);
  _wallet_exists(
    _path);
  _phrase = _file_read(_seed); 
  console.log(
    "INFO; the content of", _seed, ":", _phrase);
  // _bytes = ethers.randomBytes(512000);
  _wallet = ethers.Wallet.createRandom();
  // _mnemonic = ethers.Mnemonic.fromEntropy(
  //   _bytes);
  // console.log(
  //   "INFO Mnemonic:", _mnemonic);
  // _wallet = ethers.HDNodeWallet.fromPhrase(
  //   _phrase,
  //   _provider);
  console.log(
    _wallet);
  return _wallet
}

// async function _get(
//   _contract_address,
//   _contract_method,
//   _contract_abi,
//   _network_provider,
//   _method_args) {
//   _contract = new _ethers.BaseContract(
//     _contract_address,
//     _contract_abi,
//     runner=_network_provider);
//     _method = _contract.getFunction(
//       _contract_method);
//     _value = await _method.staticCall.apply(null, _method_args);
//   return _value;
// }

function _provider_get(
  _network,
  _api_key) {
  _provider_opts = {};
  console.log(
    "INFO: network ", _network);
  if ( _network == "gnosis" ) {
    _rpc = "https://rpc.gnosischain.com" ;
    _default_network = _rpc;
  } 
  else if ( _network == "ethereum" ) {
    if ( _api_key != "" ) {
      _default_network = "etherscan";
      _provider_opts = {
        'etherscan': _api_key,
        'exclusive': [
          "etherscan",
          "infura"
        ]
      };
    }
    else {
      _rpc="https://rpc.ankr.com/eth"
      _default_network = _rpc;
    }
  }
  else {
    _default_network = _network;
  }
  _provider = _ethers.getDefaultProvider(
    _default_network,
    _provider_opts);
  return _provider;
}

async function _wallet_new(
  _path,
  _password,
  _seed,
  _network,
  _api_key) {
  console.log(
    "INFO: network ", _network);
  _network_provider = _provider_get(
    _network,
    _api_key);
  console.log(
    "INFO: path", _path);
  console.log(
    "INFO: password", _password);
  console.log(
    "INFO: seed", _seed);
  _wallet = _wallet_get(
    _path,
    _password,
    _seed,
    _provider);
  // _value = await _get(
  //   _contract_address,
  //   _contract_method,
  //   _contract_abi,
  //   _network_provider,
  //   _method_args);
  // console.log(
  //   _value);
}

function _overrides_set() {
  if ( target_network == "" ) {
    target_network = "gnosis";
  }
}

function _cmdline_parse() {
  process.argv.forEach(
    function (
      _value,
      _index,
      _array) {
      if ( _index == 2 ) {
        wallet_path = _value;
      }
      if ( _index == 3 ) {
        wallet_password = _value;
      }
      if ( _index == 4 ) {
        wallet_seed = _value;
      }
      if ( _index == 5 ) {
        target_network = _value;
      }
      if ( _index == 6 ) {
        api_key = _value;
      }
      // if ( 5 < _index ) {
      //   wallet_seed.push(
      //     _value);
      // }
  });
  if ( wallet_path == "" ) {
    console.error(
      "Usage: wallet-new <path> <password> <seed> <network> <api_key>");
    process.exit();
  }
}

_global_variables();
_cmdline_parse();
_overrides_set();
app_opts=[
  wallet_path,
  wallet_password,
  wallet_seed,
  target_network,
  api_key
];
_wallet_new.apply(
  null,
  app_opts);
